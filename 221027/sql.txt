USE block77;
block77 디비를 사용하겠다는 뜻(해당 디비에 접속하겠다.) << 기준으로 설정한다.

CREATE SCHEMA "block77" DEFAULT CHARACTER SET utf8mb4;

CREATE TABLE `block7`.`new_table1` (
  `idx` INT NOT NULL,
  `name` VARCHAR(45) NULL,
  `password` VARCHAR(256) NULL,
  `id` VARCHAR(45) NULL,
  `create_at` DATE NULL,
  PRIMARY KEY (`idx`));

CREATE : 생성하는 명령어
- DB, TABLE 등을 생성

DEFAULT CHARACTER SET utf8mb4;
- utf8mb4 방식으로 인코딩한다. << 저장할 때의 방식이다.
- txt 파일 만들 때 인코딩방식 결정하는 것과 같은 것

`block7`.`new_table1`
- `DB명`.`생성할테이블명`

 (
  `idx` INT NOT NULL,
  `name` VARCHAR(45) NULL,
  `password` VARCHAR(256) NULL,
  `id` VARCHAR(45) NULL,
  `create_at` DATE NULL,
  PRIMARY KEY (`idx`));
  -(`컬럼명` 자료형 옵션 ,
  `컬럼명` 자료형 옵션 ,
  `컬럼명` 자료형 옵션 ,
  `컬럼명` 자료형 옵션 ,
  `컬럼명` 자료형 옵션 ,
  옵션)
  - idx 컬럼명을 INT 자료형을 사용하여 생성하되 idx는 빈값이면 안된다.
  - name 컬럼명을 VARCHAR(45) 자료형을 사용하여 생성하고 빈값이 들어가도 상관없다. ==> varchar 뒤에 숫자 = 몇 글자까지 쓸 수 있는가 = 45글자
  - PRIMARY KEY(고유 식별 컬럼, 값?)으로 idx를 설정한다.

  자료형(간단)
  - BOOLEAN : 참거짓, 1BYTE를 차지한다.
  
  자료형(숫자)
  - TINYINT : 1BYTE의 정수 << -128 ~ 127, 0 ~255 
    - 잡설 : 127 + 1 => -128 << 비폭력주의 간디의 탄생 => 0 - 1 => 255로 인식
  - INT : 4BYTE의 정수 << -2,147,483,648 ~ 2,147,483,647
  - BIGINT : 8BYTE의 정수
  - FLOAT : 4BYTE의 실수(NUMBER)
    - 계산할 때 확률적으로 오류가 뜬다.(컴퓨터 자체가 실수 계산을 잘 못함)
  - DOUBLE : 8BYTE의 실수
    - FLOAT는 조금 덜 오류가 뜬다.
  - BIT(n) : n BIT의 정수 << 몇개든지 내가 설정한다.
    - BIT(4) => 2^4 = 0~15

  자료형(문자)
  - CHAR(n) : n BYTE의 고정 문자, 최대 2^8 BYTE까지만 가능하다.
  - VARCHAR(n) : 최대 n BYTE의 가변 문자, 최대 2^8 BYTE까지만 가능
    - ASCII => 1 BYTE(8 BIT) << 최대 몇글자 ? 2^8 < 0 ~ 126 < 2^7 - 1 < 7BIT < 앞에 1 BIT를 버리고 총 8BIT로 사용한다.
    - UTF8 => 1~3 BYTE << 3BYTE 기준으로 최대로 넣을 수 있는 글자수는 2^8 / 3 ~ 2^8 // ex) 영어라면 1글자에 1BYTE, 한글이면 1글자에 3BYTE를 먹는다
    - utf8mb4 => 1~4 BYTE 
    - UTF16 => 3BYTE
  - TEXT : 최대 2^16 BYTE의 가변 문자
  - LONGTEXT : 최대 2^32 BYTE의 가변 문자

  자료형(시간)
  - DATE : 3BYTE의 날짜 => YYYY-MM-DD
  - DATETIME : 8BYTE의 날짜와 시간 => YYYY-MM-DD HH:MM:SS
  - TIMESTAMP : 4BYTE의 UTC 시간의 날짜와 시간 => YYYY-MM-DD HH:MM:SS
  - YEAR : 1BYTE의 년도 => YYYY

  옵션
  - NOT NULL : 비면 안된다.
  - UNIQUE : 값이 중복되면 안된다.
  - PRIMARY KEY : 고유 식별 키
  - FOREIGN KEY : 테이블 연결 시 사용
  - CHECK : 저장할 데이터의 범위나 조건을 지정한다.
  - DEFAULT : 기본값
  - AUTO_INCREMENT : index값 자동 증가
  - COMMENT : 설명

SELECT * FROM block77.new_table1;
SELECT : 데이터를 가져온다
* : 전부
FROM : 어디서 가져올건지

SELECT name, id FROM block77.new_table1;
block77.new_table1에서 name, id를 가져온다.

SELECT * FROM block77.new_table1 WHERE name = "어쩌구";
SELECT * FROM block77.new_table1 WHERE 조건;
SELECT * FROM block77.new_table1 WHERE name LIKE "어쩌구";
name에 "어쩌구"가 포함되어있으면 가져와라

SELECT name, id FROM block77.new_table1 ORDER BY name DESC;
name을 기준을 내림차순으로 가져온다.
SELECT name, id FROM block77.new_table1 ORDER BY name ASC;
name을 기준으로 오름차순으로 가져온다.

SELECT COUNT FROM testing.new_table1;
행의 개수 가져오기

INSERT INTO `block7`.`new_table1` (`idx`, `name`, `password`, `id`, `create_at`) VALUES ('1', '정현', 'wkdwjdgusqkqh', 'bye', '2022-10-27');

INSERT INTO `block7`.`new_table1` (`idx`, `name`, `password`, `id`, `create_at`) VALUES ('0', '가원', '123231', 'hi', '2022-10-27');

INSERT
- 데이터를 저장한다
- INTO : 어디에
- (`컬럼명`) :  (`idx`, `name`, `password`, `id`, `create_at`) (컬럼명은 생략해도된다.)
- VALUES('값') : 어떤 값들을 넣을 것인지 (컬럼명 순서와 맞춰줘야함)

INSERT INTO `block7.`new_table1` SET `idx`='0', `name`='가원', `password`='123231', `id`='hi', `create_at`='2022-10-27';

- `` << 객체(컬럼명)
- '' << 고유값(스트링이나 숫자 등등의 데이터)
